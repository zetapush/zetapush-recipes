/**
 *
 */
@zpRecipeFile::ConfirmFileUploadListener()
macroscript core_room__onConfirmFileUploadCallback(
	@NotNull map actions,
	@NotNull map file,
	@NotNull service<zpfs_hdfs> zpService
) {
	trace(#core_room__onConfirmFileUploadCallback, { actions, file });

	const { tags, type, name, metadata, creation, file: { guid, path }, owner } = file;

	var id = null;
	var resource = owner;

	if (str:len(path) > (str:len(ROOM_ATTACHMENTS_PATH) + NUMBER_OF_CHARS_IN_ROOM_ID)) {
		/** Parse file path to get room room id */
		id = str:substr(path, str:len(ROOM_ATTACHMENTS_PATH), str:len(ROOM_ATTACHMENTS_PATH) + NUMBER_OF_CHARS_IN_ROOM_ID);
		/** Get room by attachment */
		const { room } = await getRoom({
			id,
			owner
		});
		/** Set room resource */
		resource = room.resource;
		/** Grant stat for the uploaded file */
		zpServiceGroups.grant({
			action: Verb_zpfs_hdfs_stat,
			group: id,
			resource: str:join(':', zpService, owner, path),
			owner
		});
		zpServiceGroups.grant({
			action: Verb_zpfs_hdfs_freeUploadUrl,
			group: id,
			resource: str:join(':', zpService, owner, path),
			owner
		});
		trace(#core_room__onConfirmFileUploadCallback, { room });
		/** Add attachment as room message */
		const { message } = await addRoomMessage({
			room,
			type: MESSAGE_TYPE_ATTACHMENT,
			value: {
				url: file.file.url,
				guid,
				owner,
				path: str:join('/', room.metadata.attachments, guid)
			},
			metadata: metadata?: {}
		}) loud;
		/** Update message matadata */
		metadata.message = message;
		/** Notify file service of metadata */
		sudo owner zpService.updateMeta({path, metadata, owner });
		
		var stat = zpService.stat({path, owner});
	}	
} broadcast(resource) {
	string id,
	map actions,
	map file
} on channel __selfName
