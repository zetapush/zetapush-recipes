/**
 *
 */
macroscript core_room__addRoomMessageByService(
	/** Room room object */ @NotNull Room room,
	/** Message storage container id */ @ValidRoomId string container,
	/** Message type */ @ValidMessageType string type,
	/** Message value*/ @NotNull map value,
	/** Message metadata */ @NotNull map metadata,
	/** Storage Service */ @NotNull service<gda> zpService
) {
	trace(core_room__addRoomMessageByService, __parameters);
	// TODO Check permissions?
	/** Get message key */
	const { createdAt, now, key } = usr:core_room__message_key(container);
	/** Prepare data storage */
	var targets = [];
	const readers = {};
	for member in room.members {
		const { userKey } = member;
		targets += userKey;
		readers[userKey] = 0;
	}
	/** Define message structure */
	const message = { id: key, author: __userKey, type, value, createdAt, metadata, readers, targets };
	
	/** Store message */
	var res = zpService.puts({
		rows: [{
			key,
			data: {
				[COLUMN_STORAGE_AUTHOR]: __userKey,
				[COLUMN_STORAGE_TYPE]: type,
				[COLUMN_STORAGE_VALUE]: value,
				[COLUMN_STORAGE_CREATED_AT]: createdAt,
				[COLUMN_STORAGE_METADATA]: metadata,
				[COLUMN_STORAGE_READERS]: readers,
				[COLUMN_STORAGE_TARGETS]: zpRecipeUtils::reduce_array_to_map(targets)
			}
		}],
		table: TABLE_ROOM_STORAGE,
		owner: room.owner
	});
	
	trace('res', res);
	
	/** Execute all registered macros */
	zpRecipeUtils::zpServiceTrigger.trigger({
		event: EVENT__ADD_ROOM_MESSAGE,
		data: { container, room, message }
	});
} return {
	string container,
	Room room,
	Message message
} on channel __selfName
